<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

</head>
<body>
    

    <script>



        /* -------------------------------------------------函数声明-------------------------------------------  */
        //匿名函数，只能声明代码后调用。不赋值变量可以立即执行,防止变量污染
        let a=function(){console.log('无法在声明前');}
        a();
        
        
        //声明函数,可以随处调用，因为在加载前已经创建了，类似静态
        function b(){
        };


                    /*         
                    什么时候选择函数声明与函数表达式？
                    根据经验，当我们需要声明一个函数时，首先考虑 函数声明语法 。
                    它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数       
                    这对代码可读性也更好，因为在代码中查找 function f(…) {…} 比 let f = function(…) {…} 更容易。
                    函数声明更“醒目”。
                    但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。        
                    */
        

        // 箭头函数 
        let c=()=>{
              console.log('123');
            };
                     /*  箭头函数匿名函数，也可以赋值
                     this在箭头函数中，会往外边查找。事件绑定中，普通函数指向DOM，箭头指向this.
                     构造函数，原型函数，dom事件，考虑使用指向上层对象的地方.
                     也可以改变this函数的指向，并且调用
                     1.call(指向对象，参数)
                     2.apply 用于函数
                     3.bind() 不会调用
                     */            
        
        /* ------------------------------------------- ---参数传递--------------------------------------------- */
        //形式参数可以使用默认值，但是优先使用传入的（es6）。
        //匹配问题，数量不对为underfind
        function getMax(a=10,b=20){
            console.log(a+b);
        }
        
        //剩余参数
        function test(a,...args){
            console.log(a,...args);
        }
        
        //不设置参数,arguments伪数组
        function fn() {
            // console.log(arguments); // 里面存储了所有传递过来的实参  arguments = [1,2,3]
            // console.log(arguments.length);
            // console.log(arguments[2]);
            // 我们可以按照数组的方式遍历arguments
            for (var i = 0; i < arguments.length; i++) {
                console.log(arguments[i]);
            }
            }

      




        /* --------------------------------------------------关键字--------------------------------------------- */
        // return后的代码不执行。
        // 只能返回一个，但可以通过数组或集合的方式返回多个
        function name(params) {
            return params+'参数'
        }


       //continue和break;       后者退出整个循环。
       for (let i = 0; i < 5; i++) {
              if (i == 3) {
             //跳过本次循环，继续往下循环
                 continue;          
              }
             console.log('我正在吃第' + i + '个包子')
             }
       




        /* --------------------------------------------------作用域--------------------------------------------- */     
        // 全局作用域（函数外的声明的变量）
        var all=5;

        // 局部作用域,（函数内部声明的变量），代码块的变量无法被外部访问 
        let oo=10;

        // 块作用域,只能在该块内访问，还有if(),for(),且只能用let
       {
        let a=10;
        let b=20
       }

        // 作用域链，相同变量，从内外查找。结果是20
        var num = 10;
                //外部
                function fn() { 
                    
                    var num = 20;
                    //内部
                    function fun() { 
                        console.log(num);
                    }
                    fun();
                }
        fn();        



         /* --------------------------------------------------预解析--------------------------------------------- */   
              /*  1. 我们js引擎运行js 分为两步：  预解析  代码执行
                        (1). 预解析 js引擎会把js 里面所有的 var  还有 function 提升到当前作用域的最前面
                        (2). 代码执行  按照代码书写的顺序从上往下执行

                  2. 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）
                        (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面  不提升赋值操作
                        (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面  不调用函数                  
                */
    
    
                /*  解析了为什么我们可以使用
                              1.后声明函数，却可以在前边使用 ，function提升执行了。
                              2.在前访问之后的变量时，会提示underfined，因为var name;被提升执行了，却还没有赋值*/
                              
       







       // 函数是单独声明 并且调用的 函数名() 单独存在的
        // 方法 在对象里面 调用的时候 对象.方法()










        //函数作为参数就是回调函数，匿名函数常用于此，settimeout
        
        
        
        
       
        
        
        
  
        
        
   

























        // 部分案例

        // 利用函数求任意个数的最大值
        function getMax() { // arguments = [1,2,3]
            var max = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
                if (arguments[i] > max) {
                    max = arguments[i];
                }
            }
            return max;
        }



        // 翻转数组
        function reverse(arr) {
            var newArr = [];
            for (var i = arr.length - 1; i >= 0; i--) {
                newArr[newArr.length] = arr[i];
            }
            return newArr;
        }

        












        </script>
</body>
</html>